---
lab:
    az204Title: 'ラボ 02: Azure Functions を使用してタスク処理ロジックを実装する'
    az020Title: 'ラボ 02: Azure Functions を使用してタスク処理ロジックを実装する'
    az204Module: 'モジュール 02: Azure Functions の実装'
    az020Module: 'モジュール 02: Azure Functions の実装'
---

# ラボ 02: Azure Functions を使用してタスク処理ロジックを実装する

## Microsoft Azure ユーザー インターフェイス

Microsoft クラウド ツールのダイナミックな性質を考えると、このトレーニング コンテンツの開発後に Azure ユーザー インターフェイス (UI) の変更が発生する可能性があります。これらの変更により、ラボの指示と手順が一致しない場合があります。

Microsoft では、コミュニティから必要な変更要望を受けたときにトレーニング コースを更新します。ただし、クラウドの更新は頻繁に行われるため、トレーニング コンテンツの更新前に UI が変更される場合もあります。**その場合は、変更に適宜対応して、ラボで要求されている内容を処理してください。**

## 手順

### 開始する前に

#### ラボの仮想マシンにログインする

次の認証情報を使用して、Windows 10 仮想マシン (VM) にログインします。

- ユーザー名: **Admin**
- パスワード: **Pa55w.rd**

> **注**: 仮想ラボ環境に接続する手順は講師が説明します。

#### インストールされているアプリケーションを確認します

Windows 10 デスクトップでタスク バーを探します。タスク バーには、この課題で使用するアプリケーションのアイコンが含まれています:

- Microsoft Edge
- エクスプローラー
- Windows 端末
- Visual Studio Code

### 演習 1: Azure リソースを作成する

#### タスク 1: Azure portal を開きます

1. タスク バーで、**Microsoft Edge** アイコンを選択します。
1. 開いているブラウザー ウィンドウで、[Azure portal](<https://portal.azure.com>)に移動します。
1. Microsoft アカウントの電子メール アドレスを入力し、**「次へ」** を選択します。
1. Microsoft アカウントのパスワードを入力し、**「サインイン」** を選択します。
    > **注**: Azure portal に初めてログインする場合は、ポータルのツアーが表示されます。ツアーをスキップする場合は、「**開始**」 を選択してポータルの使用を開始してください。

#### タスク 2: Azure Storage アカウントを作成する

1. Azure portal のナビゲーション ペインで、「**すべてのサービス**」 を選択します。
1. 「**すべてのサービス**」 ブレードで、「**ストレージ アカウント**」 を選択します。
1. 「**ストレージア カウント**」 ブレードで、ストレージ アカウントの一覧を表示します。
1. **「ストレージ アカウント」** ブレードで、**「+ 作成」** を選択します。
1. 「**ストレージ アカウントを作成**」 ブレードで、「**基本**」、「**タグ**」、「**レビュー + 作成**」 などのブレード上のタブを確認します。
    > **注**: 各タブは、新しいストレージ アカウントを作成するための、ワークフロー内のステップを表しています。いつでも 「**Review + create**」 を選択して、残りのタブをスキップできます。
1. **基本** タブを選択し、タブ領域で次の操作を実行します。
    1. 「**サブスクリプション**」 テキスト ボックスは既定値のままにします。
    1. 「**リソース グループ**」 セクションで、「**新規作成**」 を選択して、「**Serverless**」を入力し、「**OK**」 を選択します。
    1. 「**ストレージ アカウント名**」 テキスト ボックスに「**funcstor「yourname」**」と入力します。
    1. 「**リージョン**」 リストで、「**(US) 米国東部**」 リージョンを選択します。
    1. 「**パフォーマンス**」 セクションで、「**標準**」 を選択します。
    1. 「**冗長**」 リストで、「**ローカル冗長ストレージ (LRS)**」 を選択します。
    1. 「**Review + create**」 を選択します。
1. **確認および作成**タブで、以前の手順で指定したオプションを確認します。
1. 指定した構成を使用してストレージ アカウントを作成するには、「**作成**」 を選択します。
    > **注**: **デプロイ** ブレードで次に進む前に、作成タスクが完了するまで待ちます。
1. Azure portal のナビゲーション ペインで、「**すべてのサービス**」 を選択します。
1. 「**すべてのサービス**」 ブレードで、「**ストレージ アカウント**」 を選択します。
1. 「**ストレージ アカウント**」 ブレードで、**funcstor「yourname」** ストレージ アカウント インスタンスを選択します。
1. 「**ストレージ アカウント**」 ブレードから 「**セキュリティ + ネットワーク**」 セクションを見つけ、「**アクセス キー**」 を選択します。
1. 「**アクセス キー**」 ブレードから、「**キーを表示**」 を選択します。
1. キーのいずれかを選択し、いずれかの 「**接続文字列**」 ボックスに値を記録します。
    > **注**: この値は、このラボの後半で使用します。どの接続文字列を選択しても問題ありません。これらは交換可能です。

#### タスク 3: 関数アプリを作成する

1. Azure portal のナビゲーション ペインで、「**リソースを作成**」 リンクを選択します。
1. 「**リソースの作成**」 ブレードで、「**検索サービスとマーケットプレイス**」 テキスト ボックスを見つけます。
1. 検索テキスト ボックスに「**関数**」と入力し、Enter を押します。
1. **すべて** の検索結果ブレードで、 **関数アプリ**の結果を選択します。
1. **Function App** ブレードで、「**作成**」 を選択します。
1. 「**関数アプリ**」 ブレードで、「**基本**」 などのタブを検索します。
    > **注**: 各タブは、新しい関数アプリを作成するワークフローのステップを表しています。いつでも 「**Review + create**」 を選択して、残りのタブをスキップできます。
1. 「**基本**」 タブで、次の操作を実行します。
    1. 「**サブスクリプション**」 テキスト ボックスは既定値のままにします。
    1. 「**リソースグループ**」 セクションで、「**既存のものを使用**」 を選択し、リスト上から 「**サーバーレス**」 を選択します。
    1. 「**関数アプリ名**」 テキスト ボックスに「**funclogic「yourname」**」と入力します。
    1. 「**発行**」 セクションで、「**コード**」 を選択します。
    1. 「**ランタイム スタック**」 ドロップダウン リストで、**「.NET」** を選択します。
    1. 「**バージョン**」 ドロップダウン リストで、「**3.1**」 を選択します。
    1. 「**リージョン**」 ドロップダウン リストで、「**米国東部**」 のリージョンを選択します。
    1. 「**次へ: ホスティング**
1. 「**ホスティング**」 タブで、次の操作を実行します。    
    1. 「**ストレージ アカウント**」 ドロップダウン リストで、このラボで前に作成した **funcstor「yourname」** ストレージ アカウントを選択します。
    1. 「**オペレーティング システム**」 セクションで、「**Linux**」 を選択します。
    1. 「**プランの種類**」 ドロップダウン リストで、「**従量課金プラン (サーバーレス)**」 オプションを選択します。
    1. 「**Review + create**」 を選択します。
1. 「**レビュー + 作成**」タブで、前の手順で選択したオプションをレビューします。
1. 「**作成**」を選択し、指定した構成を使用して関数アプリを作成します。
    > **注**: 演習を進める前に、作成タスクが完了するまで待ちます。

> **レビュー**: このラボでは、このラボで使用するすべてのリソースを作成しました。

### 演習 2: ローカルの Azure Functions プロジェクトを構成する

#### タスク 1: 関数プロジェクトを初期化する

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. open コマンド プロンプトが表示されたら、次のコマンドを入力し、Enter を選択して **Azure Functions Core Tools** を使用し、**dotnet** ランタイムを使用して現在のディレクトリに新しいローカル Azure Functions プロジェクトを作成します。

    ```powershell
    func init --worker-runtime dotnet --force
    ```

    > **注**: **Azure Functions Core Tools** を使用して、「新しいプロジェクトの作成」「azure-functions-core-tools-new-project」 のドキュメントを確認できます。
1. 現在実行中の **Windows Terminal** アプリケーションを閉じます。

#### タスク 2: 接続文字列を構成する

1. 「**スタート**」 スクリーンで、「**Visual Studio Code**」 タイルを選択します。
1. 「**ファイル**」 メニューで、「**フォルダーを開く**」 を選択します。
1. 開いた「**ファイル エクスプローラー**」 ウィンドウで、**Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** を参照し、「**フォルダーの選択**」 を選択します。
1. 「**Visual Studio Code**」 ウィンドウの 「Explorer」 ペインで、**local.settings.json** ファイルを開きます。
1. **AzureWebJobsStorage** 設定の現在の値を確認します。

    ```json
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    ```

1. **AzureWebJobsStorage** の値を、このラボで前に記録したストレージ アカウントの**接続文字列**に設定して更新します。
1. **local.settings.json** ファイルを保存します。

#### タスク 3: プロジェクトを構築して検証する

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. open コマンド プロンプトが表示されたら、次のコマンドを入力し、Enterを 選択して .NET Core 3.1 プロジェクトを**ビルド**します。

    ```powershell
    dotnet build
    ```

> **レビュー**: この演習では、Azure Functions の開発に使用するローカル プロジェクトを作成しました。

### 演習 3: HTTP 要求によってトリガーされる関数の作成

#### タスク 1: HTTP トリガー関数を作成する

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. open コマンドプロンプトが表示されたら、次のコマンドを入力し、Enter を選択して **Azure Functions Core Tools** を使用し、**HTTP トリガー** テンプレートを使用して **Echo** という名前の新しい関数を作成します。

    ```powershell
    func new --template "HTTP trigger" --name "Echo"
    ```

    > **注**: **Azure Functions Core Tools** を使用して、「新しい関数の作成」「azure-functions-core-tools-new-function」 のドキュメントを確認できます。
1. 現在実行中の **Windows Terminal** アプリケーションを閉じます。

#### タスク 2: HTTP でトリガーされる関数コードを書く

1. 「**スタート**」 スクリーンで、「**Visual Studio Code**」 タイルを選択します。
1. 「**ファイル**」 メニューで、「**フォルダーを開く**」 を選択します。
1. 開いた「**ファイル エクスプローラー**」 ウィンドウで、**Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** を参照し、「**フォルダーの選択**」 を選択します。
1. 「**Visual Studio Code**」 ウィンドウの 「Explorer」 ペインで、**Echo.cs** ファイルを開きます。
1. コード エディターで、例の実装を確認します。

    ```csharp
    using System;
    using System.IO;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Extensions.Http;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using Newtonsoft.Json;

    namespace func
    {
        public static class Echo
        {
            [FunctionName("Echo")]
            public static async Task<IActionResult> Run(
                [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
                ILogger log)
            {
                log.LogInformation("C# HTTP trigger function processed a request.");

                string name = req.Query["name"];

                string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
                dynamic data = JsonConvert.DeserializeObject(requestBody);
                name = name ?? data?.name;

                string responseMessage = string.IsNullOrEmpty(name)
                    ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."
                    : $"Hello, {name}. This HTTP triggered function executed successfully.";

                return new OkObjectResult(responseMessage);
            }
        }
    }
    ```

1. **Echo.cs** ファイル内のすべてのコンテンツを削除します。
1. 次のコード行を追加して、**Microsoft.AspNetCore.Mvc**、**Microsoft.Azure.WebJobs**、**Microsoft.AspNetCore.Http**、および **Microsoft.Extensions.Logging** 名前空間の **using ディレクティブ**を追加します。

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    ```

1. **Echo** という名前の新しい**パブリック静的**クラスを作成します。

    ```csharp
    public static class Echo
    { }
    ```

1. **Echo.cs** ファイルをもう一度確認します。これには次のものが含まれているはずです。

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;

    public static class Echo
    { }
    ```

1. **Echo** クラス内で、次のコード ブロックを追加して、タイプ **IActionResult** の変数を返し、タイプ **HttpRequest** および **ILogger** の変数を *request* および *logger* という名前のパラメーターとして受け取る **Run** という名前の新しい**パブリック静的**メソッドを作成します。

    ```csharp
    public static IActionResult Run(
        HttpRequest request,
        ILogger logger)
    { }
    ```

1. 次のコードを追加して、**name** パラメーターが **Echo** の値に設定されている **FunctionNameAttribute** タイプの **Run** メソッドに属性を追加します。

    ```csharp
    [FunctionName("Echo")]
    public static IActionResult Run(
        HttpRequest request,
        ILogger logger)
    { }
    ```

1. 次のコードを追加して、**methods** パラメーター配列が **POST** の単一値に設定されているタイプ **HttpTriggerAttribute** の **request** パラメーターに属性を追加します。

    ```csharp
    [FunctionName("Echo")]
    public static IActionResult Run(
        [HttpTrigger("POST")] HttpRequest request,
        ILogger logger)
    { }
    ```

1. **Echo.cs** ファイルをもう一度確認します。これには次のものが含まれているはずです。

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;

    public static class Echo
    {
        [FunctionName("Echo")]
        public static IActionResult Run(
            [HttpTrigger("POST")] HttpRequest request,
            ILogger logger)
        { }
    }
    ```

1. **Run** メソッドで、次のコード行を入力して、固定メッセージをログに記録します。

    ```csharp
    logger.LogInformation("Received a request");
    ```

1. 次のコード行を入力して、HTTP リクエストのボディを HTTP レスポンスとして出力します。

    ```csharp
    return new OkObjectResult(request.Body);
    ```

1. **Echo.cs** ファイルをもう一度確認します。これには次のものが含まれているはずです。

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;

    public static class Echo
    {
        [FunctionName("Echo")]
        public static IActionResult Run(
            [HttpTrigger("POST")] HttpRequest request,
            ILogger logger)
        {
            logger.LogInformation("Received a request");
            return new OkObjectResult(request.Body);
        }
    }
    ```

1. 「**保存**」 を選択して、変更を **Echo.cs** ファイルに保存します。

#### タスク 3: httprepl を使用して HTTP トリガー関数をテストする

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. open コマンド プロンプトが表示されたら、次のコマンドを入力し、Enterを 選択して関数アプリ プロジェクトをビルドします。

    ```powershell
    func start --build
    ```

    > **注**: **Azure Functions Core Tools** を使用して、[関数アプリ プロジェクトをローカルで開始する][azure-functions-core-tools-start-function] のドキュメントを確認できます。
1. タスクバーで、「**Windows Terminal**」 アイコンをもう一度選択して、**Windows Terminal** アプリケーションの新しいインスタンスを開きます。
1. open コマンド プロンプトが表示されたら、次のコマンドを入力し、Enter を選択して **httprepl** ツールを起動し、ベースの URI (Uniform Resource Identifier) を ``http://localhost:7071`` に設定します。

    ```powershell
    httprepl http://localhost:7071
    ```

    > **注**: httprepl ツールによってエラー メッセージが表示されます。このメッセージが発生するのは、ツールが API の「スキャン」に使用する Swagger 定義ファイルを検索しているためです。関数プロジェクトは Swagger 定義ファイルを生成しないため、API を手動でトラバースする必要があります。
1. ツールプロンプトが表示されたら、次のコマンドを入力し、Enter を選択して対応する **api** ディレクトリを参照します。

    ```powershell
    cd api
    ```

1. 次のコマンドを入力し、Enter キーを押して、対応する **echo** ディレクトリを参照します。

    ```powershell
    cd echo
    ```

1. 次のコマンドを入力し、**\-\-content** オプションを使用して、数値 **3** に設定された HTTP リクエスト本文を送信する **post** コマンドを実行します。

    ```powershell
    post --content 3
    ```

1. 次のコマンドを入力し、**\-\-content** オプションを使用して、数値 **5** に設定された HTTP リクエスト本文を送信する **post** コマンドを実行します。

    ```powershell
    post --content 5
    ```

1. 次のコマンドを入力し、**\-\-content** オプションを使用して、文字列値 **Hello** に設定された HTTP リクエスト本文を送信する **post** コマンドを実行します。

    ```powershell
    post --content "Hello"
    ```

1. 次のコマンドを入力して **post** コマンドを実行し、**{"msg": "成功"}** の値を **\-\-content** オプションを使用して、JavaScript Object Notation (JSON) に設定した HTTP 要求本文を送ります。

    ```powershell
    post --content "{"msg": "Successful"}"
    ```

1. 次のコマンドを入力してから、Enter を選択して **httprepl** アプリケーションを終了します。

    ```powershell
    exit
    ```

1. **Windows Terminal** アプリケーションの現在実行中のすべてのインスタンスを閉じます。

> **レビュー**: この演習では、HTTP POST 要求を介して送信されたコンテンツをエコーする基本的な関数を作成しました。

### 演習 4: スケジュールに基づいてトリガーする関数を作成する

#### タスク 1: スケジュールによってトリガーされる関数を作成する

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. open コマンドプロンプトが表示されたら、次のコマンドを入力し、Enter を選択して **Azure Functions Core Tools** を使用し、**Timer トリガー** テンプレートを使用して **Recurring** という名前の新しい関数を作成します。

    ```powershell
    func new --template "Timer trigger" --name "Recurring"
    ```

    > **注**: **Azure Functions Core Tools** を使用して、「新しい関数の作成」「azure-functions-core-tools-new-function」 のドキュメントを確認できます。
1. 現在実行中の **Windows Terminal** アプリケーションを閉じます。

#### タスク 2: 関数のコードを監視する

1. 「**スタート**」 スクリーンで、「**Visual Studio Code**」 タイルを選択します。
1. 「**ファイル**」 メニューで、「**フォルダーを開く**」 を選択します。
1. 開いた「**ファイル エクスプローラー**」 ウィンドウで、**Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** を参照し、「**フォルダーの選択**」 を選択します。
1. 「**Visual Studio Code」** ウィンドウの 「Explorer」 ペインで、**Recurring.cs** ファイルを開きます。
1. コード エディターで、実装を確認します。

    ```csharp
    using System;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Host;
    using Microsoft.Extensions.Logging;

    namespace func
    {
        public static class Recurring
        {
            [FunctionName("Recurring")]
            public static void Run([TimerTrigger("0 */5 * * * *")]TimerInfo myTimer, ILogger log)
            {
                log.LogInformation($"C# Timer trigger function executed at: {DateTime.Now}");
            }
        }
    }
    ```

#### タスク 3: 関数の実行を監視する

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. open コマンド プロンプトが表示されたら、次のコマンドを入力し、Enterを 選択して関数アプリ プロジェクトをビルドします。

    ```powershell
    func start --build
    ```

    > **注**: **Azure Functions Core Tools** を使用して、[関数アプリ プロジェクトをローカルで開始する][azure-functions-core-tools-start-function] のドキュメントを確認できます。
1. 約 5 分ごとに発生する関数の実行を観察します。各関数の実行は、ログに単純なメッセージを書き込む必要があります。
1. 現在実行中の **Windows Terminal** アプリケーションを閉じます。

#### タスク 4: 関数統合構成を更新する

1. 「**スタート**」 スクリーンで、「**Visual Studio Code**」 タイルを選択します。
1. 「**ファイル**」 メニューで、「**フォルダーを開く**」 を選択します。
1. 開いた「**ファイル エクスプローラー**」 ウィンドウで、**Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** を参照し、「**フォルダーの選択**」 を選択します。
1. 「**Visual Studio Code」** ウィンドウの 「Explorer」 ペインで、**Recurring.cs** ファイルを開きます。
1. コード エディターで、既存の **Run** メソッドのシグネチャを確認します。

    ```csharp
    [FunctionName("Recurring")]
    public static void Run([TimerTrigger("0 */5 * * * *")]TimerInfo myTimer, ILogger log)
    ```

1. **Run** メソッドのシグネチャを更新して、**30 秒**に 1 回実行するようにスケジュールを変更します。

    ```csharp
    [FunctionName("Recurring")]
    public static void Run([TimerTrigger("*/30 * * * * *")]TimerInfo myTimer, ILogger log)
    ```

1. 「**保存**」 を選択して、変更を **Recurring.cs** ファイルに保存します。

#### タスク 5: 関数の実行を監視する

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. open コマンド プロンプトが表示されたら、次のコマンドを入力し、Enterを 選択して関数アプリ プロジェクトをビルドします。

    ```powershell
    func start --build
    ```

    > **注**: **Azure Functions Core Tools** を使用して、「関数アプリ プロジェクトをローカルで開始する」「azure-functions-core-tools-start-function」 のドキュメントを確認できます。
1. 約 30 秒ごとに発生する関数の実行を観察します。各関数の実行は、ログに単純なメッセージを書き込む必要があります。
1. 現在実行中の **Windows Terminal** アプリケーションを閉じます。

> **レビュー**: この演習では、固定スケジュールに基づいて自動的に実行される関数を作成しました。

### 演習 5: 他のサービスと統合する関数を作成する

#### タスク 1: サンプル コンテンツを Azure BLOB ストレージにアップロードする

1. Azure portal のナビゲーション ペインで、「**リソース グループ**」 リンクを選択します。
1. 「**リソース グループ**」 ブレードで、 この課題で前に作成した "**サーバーレス**" リソースグループを検索して選択します。
1. 「**サーバーレス**」 ブレードで、この課題で先ほど作成した **funcstor「yourname」** ストレージ アカウントを選択します。
1. 「**ストレージ アカウント**」 ブレードで、「**データ ストレージ**」 セクションにある 「**コンテナー**」 を選択します。
1. 「**コンテナー**」 セクションで、「**+ コンテナー**」 を選択します。
1. 「**新規コンテナー**」 ポップアップ ウィンドウで、次の操作を実行します。
    1. 「**名前**」 テキストボックスに、「**content**」を入力します。
    1. 「**パブリック アクセス レベル**」 ドロップダウン リストで、「**プライベート (匿名アクセスなし)**」 を選択します。
    1. 「**作成**」を選択します。
1. 「**コンテナー**」 セクションに戻り、最近作成した **content** コンテナーを選択します。
1. 「**コンテナー**」 ブレードで、「**アップロード**」 を選択します。
1. 「**BLOB をアップロード**」 ウィンドウで、次の操作を実行します。
    1. 「**ファイル**」 セクションで、「**フォルダー**」 アイコンを選択します。
    1. 「**ファイルエクスプローラー**」 ウィンドウで、「**すべてのファイル :\\Allfiles\\Labs\\02\\Starter**」 を参照し、**settings.json** ファイルを選択して 「**開く**」 をクリックします。
    1. **「ファイルが既に存在する場合は上書きする」** チェックボックスがオンにチェックされていることを確認し、**「アップロード」** を選択します。
      > **注**: この演習を続行する前に、BLOB がアップロードされるのを待ちます。

#### タスク 2: HTTP トリガ関数の作成

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. open コマンドプロンプトが表示されたら、次のコマンドを入力し、Enter を選択して A**Azure Functions Core Tools** を使用し、**HTTP トリガー** テンプレートを使用して **GetSettingInfo** という名前の新しい関数を作成します。

    ```powershell
    func new --template "HTTP trigger" --name "GetSettingInfo"
    ```

    > **注**: **Azure Functions Core Tools** を使用して、「新しい関数の作成」「azure-functions-core-tools-new-function」 のドキュメントを確認できます。
1. 現在実行中の **Windows Terminal** アプリケーションを閉じます。

#### タスク 3: HTTP トリガーおよび BLOB 入力関数コードを記述する

1. 「**スタート**」 スクリーンで、「**Visual Studio Code**」 タイルを選択します。
1. 「**ファイル**」 メニューで、「**フォルダーを開く**」 を選択します。
1. 開いた「**ファイル エクスプローラー**」 ウィンドウで、**Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** を参照し、「**フォルダーの選択**」 を選択します。
1. 「**Visual Studio Code**」 ウィンドウの 「Explorer」 ペインで、**GetSettingInfo.cs** ファイルを開きます。
1. コード エディターで、例の実装を確認します。

    ```csharp
    using System;
    using System.IO;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Extensions.Http;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using Newtonsoft.Json;
    
    namespace func
    {
        public static class GetSettingInfo
        {
            [FunctionName("GetSettingInfo")]
            public static async Task<IActionResult> Run(
                [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
                ILogger log)
            {
                log.LogInformation("C# HTTP trigger function processed a request.");
    
                string name = req.Query["name"];
    
                string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
                dynamic data = JsonConvert.DeserializeObject(requestBody);
                name = name ?? data?.name;
    
                string responseMessage = string.IsNullOrEmpty(name)
                    ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."
                    : $"Hello, {name}. This HTTP triggered function executed successfully.";
    
                return new OkObjectResult(responseMessage);
            }
        }
    }
    ```

1. **GetSettingInfo.cs** ファイル内のすべてのコンテンツを削除します。

1. 次のコード行を追加して、**Microsoft.AspNetCore.Http**、**Microsoft.AspNetCore.Mvc**、**Microsoft.Azure.WebJobs** 名前空間の **using ディレクティブ**を追加します。

    ```csharp
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    ```

1. **GetSettingInfo** という名前の新しい**パブリック静的**クラスを作成します。

    ```csharp
    public static class GetSettingInfo
    { }
    ```

1. **GetSettingInfo.cs** ファイルをもう一度確認します。これには次のものが含まれているはずです。

    ```csharp
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;

    public static class GetSettingInfo
    { }
    ```

1. **GetSettingInfo** クラス内で、次のコード ブロックを追加して、タイプ **IActionResult** の変数を返し、タイプ **HttpRequest** および**文字列**の変数を *request* および *json* という名前のパラメーターとして受け取る **Run** という名前の新しい**パブリック静的** expression-bodied メソッドを作成します。

    ```csharp
    public static IActionResult Run(
        HttpRequest request,
        string json)
        => null;
    ```

    > **注**: 戻り値を一時的に **null** に設定しているだけです。

1. 次のコードを追加して、**name** パラメーターが **GetSettingInfo** の値に設定されている **FunctionNameAttribute** タイプの **Run** メソッドに属性を追加します。

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        HttpRequest request,
        string json)
        => null;
    ```

1. 次のコードを追加して、**methods** パラメーター配列が **GET** の単一値に設定されているタイプ **HttpTriggerAttribute** の **request** パラメーターに属性を追加します。

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        [HttpTrigger("GET")] HttpRequest request,
        string json)
        => null;
    ```

1. 次のコードを追加し、**blobPath** パラメーターが **content/settings.json** の値に設定されている **BlobAttribute** タイプの **json** パラメーターに属性を追加します。

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        [HttpTrigger("GET")] HttpRequest request,
        [Blob("content/settings.json")] string json)
        => null;
    ```

1. 次のコードを追加し、**Run** expression-bodied メソッドを更新して、**json** メソッド パラメーターの値を唯一のコンストラクター パラメーターとして渡す **OkObjectResult** クラスの新しいインスタンスを返します。

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        [HttpTrigger("GET")] HttpRequest request,
        [Blob("content/settings.json")] string json)
        => new OkObjectResult(json);
    ```

1. **GetSettingInfo.cs** ファイルをもう一度確認します。これには次のものが含まれているはずです。

    ```csharp
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;

    public static class GetSettingInfo
    {
        [FunctionName("GetSettingInfo")]
        public static IActionResult Run(
            [HttpTrigger("GET")] HttpRequest request,
            [Blob("content/settings.json")] string json)
            => new OkObjectResult(json);
    }
    ```

1. 「**保存**」 を選択して、変更を **GetSettingInfo.cs** ファイルに保存します。

#### タスク 4: Azure Storage BLOB 拡張機能を登録する

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. open コマンド プロンプトが表示されたら、次のコマンドを入力し、Enter を選択して [Microsoft.Azure.WebJobs.Extensions.Storage](https://www.nuget.org/packages/Microsoft.Azure.WebJobs.Extensions.Storage/4.0.4) 拡張機能を**登録**します。

    ```powershell
    func extensions install --package Microsoft.Azure.WebJobs.Extensions.Storage --version 4.0.4
    ```

1. 次のコマンドを入力し、Enter を選択して、.NET プロジェクトを**ビルド**することにより、拡張機能が正しくインストールされたことを確認します。

    ```powershell
    dotnet build
    ```

1. **Windows Terminal** アプリケーションの現在実行中のすべてのインスタンスを閉じます。

#### タスク 5: httprepl を使用して関数をテストする

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. open コマンド プロンプトが表示されたら、次のコマンドを入力し、Enterを 選択して関数アプリ プロジェクトをビルドします。

    ```powershell
    func start --build
    ```

    > **注**: **Azure Functions Core Tools** を使用して、「関数アプリ プロジェクトをローカルで開始する」 「azure-functions-core-tools-start-function」 のドキュメントを確認できます。
1. タスクバーで、「**Windows Terminal**」 アイコンをもう一度選択して、**Windows Terminal** アプリケーションの新しいインスタンスを開きます。
1. open コマンド プロンプトが表示されたら、次のコマンドを入力し、Enter を選択して **httprepl** ツールを起動し、ベースの URI (Uniform Resource Identifier) を ``http://localhost:7071`` に設定します。

    ```powershell
    httprepl http://localhost:7071
    ```

    > **注**: httprepl ツールによってエラー メッセージが表示されます。このメッセージが発生するのは、ツールが API の「スキャン」に使用する Swagger 定義ファイルを検索しているためです。関数プロジェクトは Swagger 定義ファイルを生成しないため、API を手動でトラバースする必要があります。
1. ツールプロンプトが表示されたら、次のコマンドを入力し、Enter を選択して対応する **api** エンドポイントを参照します。

    ```powershell
    cd api
    ```

1. 次のコマンドを入力して、対応する **getsettinginfo** エンドポイントを参照します。

    ```powershell
    cd getsettinginfo
    ```

1. 次のコマンドを入力し、現在のエンドポイントで **get** コマンドを実行します。

    ```powershell
    get
    ```

1. 関数アプリからのレスポンスに含まれる JSON コンテンツを確認します。関数アプリには次の内容が含まれています。

    ```json
    {
        "version": "0.2.4",
        "root": "/usr/libexec/mews_principal/",
        "device": {
            "id": "21e46d2b2b926cba031a23c6919"
        },
        "notifications": {
            "email": "joseph.price@contoso.com",
            "phone": "(425) 555-0162 x4151"
        }
    }
    ```

1. 次のコマンドを入力してから、Enter を選択して **httprepl** アプリケーションを終了します。

    ```powershell
    exit
    ```

1. **Windows Terminal** アプリケーションの現在実行中のすべてのインスタンスを閉じます。

> **レビュー**: このエクササイズでは、ストレージ内の JSON ファイルの内容を返す関数を作成しました。

### 演習 6: Azure Functions アプリに ローカル関数プロジェクトをデプロイする

#### タスク 1: Azure Functions Core Tools を使用してデプロイする

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\02\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\02\Starter\func
    ```

1. open コマンド プロンプトが表示されたら、次のコマンドを入力し、Enter を選択して Azure コマンド ライン インターフェイス (CLI) にログインします。

    ```powershell
    az login
    ```

1. **Microsoft Edge** ブラウザー ウィンドウで、次の操作を実行します。
    1. Microsoft アカウントの電子メール アドレスを入力し、**「次へ」** を選択します。
    1. Microsoft アカウントのパスワードを入力し、**「サインイン」** を選択します。
1. 現在開いている 「**Windows Terminal**」 ウィンドウに戻ります。サインイン プロセスが完了するのを待ちます。
1. 次のコマンドを入力し、Enter を選択して関数アプリ プロジェクトを公開します。

    ```powershell
    func azure functionapp publish <function-app-name>
    ```

    > **注**: たとえば、**関数アプリ名**が **funclogicstudent** の場合、コマンドは ``func azure functionapp publish funclogicstudent`` になります。**Azure Functions Core Tools** を使用して、[ローカル関数アプリ プロジェクトを公開する][azure-functions-core-tools-publish-azure]のドキュメントを確認できます。
1. ラボを進める前に、デプロイが完了するのを待ちます。
1. 現在実行中の **Windows Terminal** アプリケーションを閉じます。

#### タスク 2: デプロイの検証

1. タスク バーで、**Microsoft Edge** アイコンを選択します。
1. 開いているブラウザー ウィンドウで、[Azure portal](<https://portal.azure.com>)に移動します。
1. Azure portal のナビゲーション ペインで、「**リソース グループ**」 リンクを選択します。
1. 「**リソース グループ**」 ブレードで、 この課題で前に作成した "**サーバーレス**" リソースグループを検索して選択します。
1. 「**サーバーレス**」 ブレードで、このラボで前に作成した **funclogic 「yourname」** 関数アプリを選択します。
1. 「**App Service**」 ブレードで、「**関数**」 セクションから 「**関数**」 オプションを選択ます。
1. 「**関数**」 ペインで、既存の **GetSettingInfo** 関数を選択します。
1. 「**関数**」 ブレードで、「**開発者**」 セクションから 「**コード + テスト**」 オプションを選択します。
1. 関数エディターで、「**テスト/実行**」 を選択します。
1. 表示されるポップアップ ダイアログで、次の操作を実行します。
    - 「**HTTP メソッド**」 リストで、「**GET**」 を選択します。
1. 「**実行**」 を選択して関数をテストします。
1. テスト実行の結果を確認します。JSON コンテンツには次のものが含まれているはずです。

    ```json
    {
        "version": "0.2.4",
        "root": "/usr/libexec/mews_principal/",
        "device": {
            "id": "21e46d2b2b926cba031a23c6919"
        },
        "notifications": {
            "email": "joseph.price@contoso.com",
            "phone": "(425) 555-0162 x4151"
        }
    }
    ```

> **レビュー**: この演習では、ローカル関数プロジェクトを Azure Functions にデプロイし、関数が Azure で機能することを検証しました。

### 演習 7: サブスクリプションのクリーンアップ

#### タスク 1: Azure Cloud Shellを開き、リソース グループを一覧表示する

1.  Azure potalの上部で、**Cloud Shell** アイコンを選択して新しいシェル インスタンスを開きます。
    > **注**: **Cloud Shell** アイコンは、署名 (\>) アンダースコア文字 (\_) より大きく表されます。
1. サブスクリプションを使用して Cloud Shell を初めて開く場合は、**Azure Cloud Shell へようこそウィザード**を使って、初めて使用する Cloud Shell を構成できます。ウィザードで次の操作を実行します。
    1. ダイアログ ボックスで、シェルを構成するように求められます。**「Bash」** を選択し、選択したサブスクリプションを確認してから、**「ストレージの作成」** を選択します。
    > **注**: Cloud Shell が初回のセットアップ手順を完了するのを待ってから、ラボを進めます。Cloud Shell 構成オプションが表示されない場合は、このコースのラボで既存のサブスクリプションを使用している可能性があります。新しいサブスクリプションを使用しているという前提で課題を記述します。

#### タスク 2: リソース グループの削除

1. コマンド プロンプトが表示されたら、次のコマンドを入力し、Enter を選択して**サーバーレス** リソース グループを削除します。

    ```powershell
    az group delete --name Serverless --no-wait --yes
    ```

1. ポータルの Cloud Shell ペインを閉じます。

#### タスク 3: アクティブなアプリケーションを閉じる

1. 現在実行中の Microsoft Edge アプリケーションを閉じます。

> **レビュー**: この実習では、この演習で使用したリソース グループを削除してサブスクリプションをクリーンアップしました。

[azure-functions-core-tools-new-function]: https://docs.microsoft.com/azure/azure-functions/functions-run-local#create-func
[azure-functions-core-tools-new-project]: https://docs.microsoft.com/azure/azure-functions/functions-run-local#create-a-local-functions-project
[azure-functions-core-tools-start-function]: https://docs.microsoft.com/azure/azure-functions/functions-run-local#start
[azure-functions-core-tools-publish-azure]: https://docs.microsoft.com/azure/azure-functions/functions-run-local#publish
