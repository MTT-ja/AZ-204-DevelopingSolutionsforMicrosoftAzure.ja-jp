---
lab:
    az204Title: 'ラボ 07: サービス間でリソース シークレットに安全にアクセスする'
    az020Title: 'ラボ 07: サービス間でリソース シークレットに安全にアクセスする'
    az204Module: 'モジュール 07: セキュアなクラウド ソリューションの実装'
    az020Module: 'モジュール 07: セキュアなクラウド ソリューションの実装'
---

# ラボ 07: サービス間でリソース シークレットに安全にアクセスする

## Microsoft Azure ユーザー インターフェイス

Microsoft クラウド ツールのダイナミックな性質を考えると、このトレーニング コンテンツの開発後に Azure ユーザー インターフェイス (UI) の変更が発生する可能性があります。これらの変更により、ラボの指示と手順が一致しない場合があります。

Microsoft では、コミュニティから必要な変更要望を受けたときにトレーニング コースを更新します。ただし、クラウドの更新は頻繁に行われるため、トレーニング コンテンツの更新前に UI が変更される場合もあります。**その場合は、変更に適宜対応して、ラボで要求されている内容を処理してください。**

## 手順

### 開始する前に

#### ラボの仮想マシンにログインする

次の認証情報を使用して、Windows 10 仮想マシン (VM) にログインします。

- ユーザー名: **Admin**
- パスワード: **Pa55w.rd**

> **注**: 仮想ラボ環境に接続する手順は講師が説明します。

#### インストールされているアプリケーションを確認します

Windows 10 デスクトップでタスク バーを探します。タスク バーには、この課題で使用するアプリケーションのアイコンが含まれています:

- Microsoft Edge
- エクスプローラー
- Windows 端末
- Visual Studio Code

### 演習 1: Azure リソースを作成する

#### タスク 1: Azure portal を開きます

1. タスク バーで、**Microsoft Edge** アイコンを選択します。
1. 開いているブラウザー ウィンドウで、**Azure portal** (<https://portal.azure.com>) に移動します。
1. Microsoft アカウントの電子メール アドレスを入力し、**「次へ」** を選択します。
1. Microsoft アカウントの**パスワード**を入力し、「**サインイン**」 を選択 します。

    > **注**: Azure portal に初めてサインインする場合は、ポータルのツアーが表示されます。ツアーをスキップする場合は、「**開始**」 を選択してポータルの使用を開始してください。

#### タスク 2: Azure Storage アカウントを作成する

1. Azure portal のナビゲーション ペインで、「**すべてのサービス**」 を選択します。
1. 「**すべてのサービス**」 ブレードで、「**ストレージ アカウント**」 を選択します。
1. 「**ストレージ アカウント**」 ブレードで、ストレージ インスタンスの一覧を表示します。
1. **「ストレージ アカウント」** ブレードで、**「+ 作成」** を選択します。
1. 「**ストレージ アカウントの作成**」 ブレードで 「**基本**」 などのタブを探します。

    > **注**: 各タブは、新しいストレージ アカウントを作成するための、ワークフロー内のステップを表しています。いつでも 「**Review + create**」 を選択して、残りのタブをスキップできます。
1. 「**基本**」 タブで、次の操作を実行します:
    1. 「**サブスクリプション**」 テキスト ボックスは既定値のままにします。
    1. 「**リソース グループ**」 セクションで、「**新規作成**」 を選択し、「**ConfidentialStack**」を入力し、「**OK**」 を選択します。
    1. 「**ストレージ アカウント名**」 テキスト ボックスに、「**securestor「yourname」**」と入力します。
    1. 「**場所**」 ドロップダウン リストで、「**(US) 米国東部**」 リージョンを選択します。
    1. 「**パフォーマンス**」 セクションで、「**標準**」 を選択します。
    1. 「**冗長**」 ドロップダウン リストで、「**ローカル冗長ストレージ (LRS)**」 を選択します。
    1. 「**Review + create**」 を選択します。
1. 「**Review + create**」 タブで、前の手順で選択したオプションを確認します。
1. 指定した構成を使用してストレージ アカウントを作成するには、「**作成**」 を選択します。
    > **注**: 演習を進める前に、作成タスクが完了するまで待ちます。
1. Azure portal のナビゲーション ペインで、「**すべてのサービス**」 を選択します。
1. 「**すべてのサービス**」 ブレードで、「**ストレージ アカウント**」 を選択します。
1. 「**ストレージ アカウント**」 ブレードで、このラボで先ほど作成した **securestor「yourname」** ストレージ アカウントを選択します。
1. **「ストレージ アカウント」** ブレードで **「セキュリティ + ネットワーク」** セクションを見つけ、**アクセス キー** リンクを選択します。
1. 「**アクセス キー**」 ブレードから、「**キーを表示**」 を選択します。
1. キーのいずれかを選択し、いずれかの 「**接続文字列**」 ボックスに値を記録します。この値は、このラボの後半で使用します。
    > **注**: どの接続文字列を選択しても問題ありません。これらは交換可能です。

#### タスク 3: Azure Key Vault を作成する

1. Azure portal のナビゲーション ペインで、「**リソースを作成**」 リンクを選択します。
1. 「**リソースの作成**」 ブレードで、「**検索サービスとマーケットプレイス**」 テキスト ボックスを見つけます。
1. 検索ボックスに「**Key Vault**」と入力し、Enter キーを押します。
1. 「**Marketplace**」 検索結果ブレードで、「**Key Vault**」 の結果を選択します。
1. 「**Key Vault**」 ブレードで、「**作成**」 を選択します。
1. 「**キー コンテナーの作成**」 ブレードから 「**基本**」 などのタブを見つけます。
    > **注**: 各タブは、新しいキー コンテナーを作成するためのワークフロー内のステップを表しています。いつでも 「**Review + create**」 を選択して、残りのタブをスキップできます。
1. 「**基本**」 タブで、次の操作を実行します:
    1. 「**サブスクリプション**」 テキスト ボックスは既定値のままにします。
    1. 「**リソースグループ**」 セクションで、「**既存のものを使用**」 を選択し、リスト上から 「**ConfidentialStack**」 を選択します。
    1. 「**Key Vault 名**」 テキストボックスに「**securevault「yourname」**」と入力します。
    1. 「**リージョン**」 ドロップダウン リストで、「**米国東部**」 のリージョンを選択します。
    1. **価格レベル**のドロップダウン リストで、**Standard** を選択します。
    1. 「**Review + create**」 を選択します。
1. 「**Review + create**」 タブで、前の手順で選択したオプションを確認します。
1. 指定した構成を使用してキー コンテナーを作成するには、「**作成**」 を選択します。
    > **注**: 演習を進める前に、作成タスクが完了するまで待ちます。

#### タスク 4: Azure Functions アプリを作成する

1. Azure portal のナビゲーション ペインで、「**リソースを作成**」 リンクを選択します。
1. 「**リソースの作成**」 ブレードで、「**検索サービスとマーケットプレイス**」 テキスト ボックスを見つけます。
1. 検索テキスト ボックスに「**関数**」と入力し、Enter を押します。
1. 「**Marketplace**」 検索結果ブレードで、「**Function App**」 の結果を選択します。
1. 「**Function App**」 ブレードで、「**作成**」 を選択します。
1. 「**Function App**」 ブレードから、「**基本**」 などのタブを見つけます。
    > **注**: 各タブは、新しい関数アプリを作成するワークフローのステップを表しています。いつでも 「**Review + create**」 を選択して、残りのタブをスキップできます。
1. 「**基本**」 タブで、次の操作を実行します:
    1. 「**サブスクリプション**」 テキスト ボックスは既定値のままにします。
    1. 「**リソースグループ**」 セクションで、「**既存のものを使用**」 を選択し、リスト上から 「**ConfidentialStack**」 を選択します。
    1. 「**関数アプリ名**」 テキスト ボックスに「**securefunc「yourname」**」と入力します。
    1. 「**発行**」 セクションで、「**コード**」 を選択します。
    1. 「**ランタイム スタック**」 ドロップダウン リストで、**「.NET」** を選択します。
    1. 「**バージョン**」 ドロップダウン リストで、「**3.1**」 を選択します。
    1. 「**リージョン**」 ドロップダウン リストで、「**米国東部**」 のリージョンを選択します。
    1. 「**次へ: ホスティング**
1. 「**ホスティング**」 タブで、次の操作を実行します:
    1. 「**ストレージ アカウント**」 ドロップダウン リストで、このラボで前に作成した **securestor[yourname]** ストレージ アカウントを選択します。
    1. 「**オペレーティング システム**」 セクションで、「**Linux**」 を選択します。
    1. 「**プランの種類**」 ドロップダウン リストで、「**従量課金プラン (サーバーレス)**」 オプションを選択します。
    3. 「**Review + create**」 を選択します。
1. 「**Review + create**」 タブで、前の手順で選択したオプションを確認します。
1. 「**作成**」を選択し、指定した構成を使用して関数アプリを作成します。
    > **注**: 演習を進める前に、作成タスクが完了するまで待ちます。

> **レビュー**: このラボでは、このラボで使用するすべてのリソースを作成しました。

### 演習 2: シークレットと ID の構成

#### タスク 1: システム割り当てマネージド サービス ID を構成する

1. Azure portal のナビゲーション ペインで、「**リソース グループ**」 リンクを選択します。
1. 「**リソース グループ**」 ブレードで、 この実習ラボで前に作成した **ConfidentialStack** リソース グループを見つけて選択します。
1. 「**ConfidentialStack**」 ブレードで、このラボで前に作成した **securefunc「yourname」** 関数アプリを選択します。
    > **注**: 2　つの (同じ名前の関数アプリとアプリケーション インサイトリソース) リソースがあります。関数アプリ リソースを選択していることを確認してください。
1. 「**Function App**」 ブレードで、「**設定**」 セクションから 「**ID**」 オプションを選択します。
1. 「**ID**」 ペインから、「**システム割り当て**」 タブを見つけて、次のアクションを実行します。
    1. 「**状態**」 セクションで 「**オン**」 を選択し、「**保存**」 を選択します。
    1. 確認ダイアログ ボックスで 「**はい**」 を選択します。
    > **注**: この課題を進める前に、システムに割り当てられたマネージド ID が作成されるまで待ちます。

#### タスク 2: Key Vault シークレットを作成する

1. Azure portal のナビゲーション ペインで、「**リソース グループ**」 リンクを選択します。
1. 「**リソース グループ**」 ブレードで、 この実習ラボで前に作成した **ConfidentialStack** リソース グループを見つけて選択します。
1. 「**ConfidentialStack」** ブレードで、このラボの前半で作成した **securevault「yourname」** キー コンテナーを選択します。
1. 「**キー コンテナー**」 ブレードの 「**設定**」 セクションにある 「**シークレット**」 リンクを選択します。
1. **シークレット**ペインで、**+生成/インポート**を選択します。
1. 「**シークレットの作成**」 ブレードで、次の操作を実行します。
    1. 「**アップロード オプション**」 ドロップダウン リストで、「**手動**」 を選択します。
    1. 「**名前**」 テキスト ボックスに、「**storagecredentials**」と入力します。
    1. 「**値**」 テキスト ボックスに、この演習で前に記録したストレージ アカウント接続文字列を入力します。
    1. 「**コンテンツの種類**」 テキスト ボックスは既定値のままにします。
    1. 「**アクティブ化する日を設定する**」 テキスト ボックスは既定値のままにします。
    1. 「**有効期限を設定する**」 テキスト ボックスは既定値のままにします。
    1. 「**有効**」 セクションで 「**はい**」 を選択し、「**作成**」 を選択します。
    > **注**: この課題を進める前に、シークレットが作成されるのを待ちます。
1. 「シークレット」 ペインに戻り、リストから **storagecredentials** アイテムを選択します。
1. バージョン ウインドウで、**storagecredentials** シークレットの最新バージョンを選択します。
1. シークレット バージョン ウインドウで、次の操作を実行します。
    1. シークレットの最新バージョンのメタデータを確認します。
    1. シークレットの値を表示するには、「**シークレット値の表示**」 を選択します。
    1. 後の演習で使用するため、「**シークレット識別子**」 テキスト ボックスの値を記録します。
    > **注**: 「**シークレット値**」 テキスト ボックスではなく、「**シークレット識別子**」 テキスト ボックスの値を記録しています。

#### タスク 3: キー コンテナー アクセス ポリシーの構成

1. Azure portal のナビゲーション ペインで、「**リソース グループ**」 リンクを選択します。
1. 「**リソース グループ**」 ブレードで、 この実習ラボで前に作成した **ConfidentialStack** リソース グループを見つけて選択します。
1. 「**ConfidentialStack」** ブレードで、このラボの前半で作成した **securevault「yourname」** キー コンテナーを選択します。
1. 「**キー コンテナー**」 ブレードで、「**設定**」 セクションにある 「**アクセス ポリシー**」 リンクを選択します。
1. アクセス ポリシー ウィンドウで、「**アクセス ポリシーの追加**」 を選択します。
1. 「**アクセス ポリシーの追加**」 ブレードで、次の操作を実行します。
    1. 「**プリンシパルの選択**」 リンクを選択します。
    1. 「**プリンシパル**」 ブレードから、**securefunc「yourname」** という名前のサービス プリンシパルを見つけてから選択し、次に 「**選択**」 を選択します。
        > **注**: このラボの前半で作成したシステム割り当てマネージド ID は、Azure 関数リソースと同じ名前になります。
    1. 「**キーのアクセス許可**」 リストは既定値に設定したままにします。
    1. 「**シークレットのアクセス許可**」 ドロップダウン リストで、「**GET**」 アクセス許可を選択します。
    1. 「**証明書のアクセス許可**」 リストは、既定値に設定したままにします。
    1. 「**承認されているアプリケーション**」 テキスト ボックスは、既定値のままにしておきます。
    1. 「**追加**」を選択します。
1. アクセス ポリシー ウィンドウに戻って、「**保存**」 を選択します。
    > **注**: この演習を進める前に、アクセス ポリシーに対する変更が保存されるのを待ちます。

#### タスク 4: キー ボルト派生アプリケーション設定を作成する

1. Azure portal のナビゲーション ペインで、「**リソース グループ**」 リンクを選択します。
1. 「**リソース グループ**」 ブレードで、 この実習ラボで前に作成した **ConfidentialStack** リソース グループを見つけて選択します。
1. 「**ConfidentialStack**」 ブレードで、このラボで前に作成した **securefunc「yourname」** 関数アプリを選択します。
1. 「**App Service**」 ブレードで、「**設定**」 セクションから 「**構成**」 オプションを選択します。
1. 「**構成**」 ペインから、次のアクションを実行します。
    1. 「**アプリケーションの設定**」 タブを選択し、「**新しいアプリケーション設定**」 を選択します。
    1. 「**アプリケーションの追加/編集**」 ポップアップ ウィンドウで、「**名前**」 テキスト ボックスに「**StorageConnectionString**」と入力します。
    1. 「**値**」 テキスト ボックスで、次の構文を使用して値を作成します。``@Microsoft.KeyVault(SecretUri=*Secret Identifier*)``
        > **注**: 上記の構文を使用して、***シークレット識別子*** への参照を構築する必要があります。たとえば、シークレット識別子が ``https://securevaultstudent.vault.azure.net/secrets/storagecredentials/17b41386df3e4191b92f089f5efb4cbf`` である場合、値は ``@Microsoft.KeyVault(SecretUri=https://securevaultstudent.vault.azure.net/secrets/storagecredentials/17b41386df3e4191b92f089f5efb4cbf)`` になります。
    1. 「**配置スロット設定**」 テキスト ボックスは、既定値のままにしておきます。
    1. 「**OK**」 を選択してポップアップ ウィンドウを閉じ、「**構成**」 セクションに戻ります。
    1. ブレードで 「**保存**」 を選択して、設定を保存します。  
    1. 「**変更の保存の確認**」 ポップアップダイアログ ボックスで、「**続行**」 を選択します。
    > **注**: 課題を進める前に、アプリケーションの設定が保存されるまで待ちます。

> **レビュー**: この演習では、関数アプリにシステムが割り当てたマネージド サービス ID を作成し、その ID に適切な権限を付与して、Key Vault のシークレットの値を取得しました。最後に、関数アプリの構成設定内で参照するシークレットを作成しました。

### 演習 3: Azure Functions アプリをビルドする

#### タスク 1: 関数プロジェクトを初期化する

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. open コマンド プロンプトで、次のコマンドを入力し、Enter を選択して **Azure Functions Core Tools** を使用し、**dotnet** ランタイムを使用して現在のディレクトリに新しいローカル Functions プロジェクトを作成します。

    ```powershell
    func init --worker-runtime dotnet --force
    ```

    > **注**: **Azure Functions Core Tools** を使用して、「新しいプロジェクトの作成」「azure-functions-core-tools-new-project」 のドキュメントを確認できます。
1. 次のコマンドを入力し、Enter を選択して .NET Core 3.1 プロジェクトを**ビルド**します。

    ```powershell
    dotnet build
    ```

#### タスク 2: HTTP トリガー関数を作成する

1. 引き続き open コマンドプロンプトで、次のコマンドを入力し、Enter を選択して **Azure Functions Core Tools** を使用し、**HTTP トリガー** テンプレートを使用して **FileParser** という名前の新しい関数を作成します。

    ```powershell
    func new --template "HTTP trigger" --name "FileParser"
    ```

    > **注**: **Azure Functions Core Tools** を使用して、「新しい関数の作成」「azure-functions-core-tools-new-function」 のドキュメントを確認できます。
1. 現在実行中の **Windows Terminal** アプリケーションを閉じます。

#### タスク 3: アプリケーション設定を構成して読み取る

1. 「**スタート**」 スクリーンで、「**Visual Studio Code**」 タイルを選択します。
1. 「**ファイル**」 メニューで、「**フォルダーを開く**」 を選択します。
1. 開いた「**ファイル エクスプローラー**」 ウィンドウで、**Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** を参照し、「**フォルダーの選択**」 を選択します。
1. 「**Visual Studio Code**」 ウィンドウの 「Explorer」 ペインで、**local.settings.json** ファイルを開きます。
1. **Values** オブジェクトの現在の値を確認します。

    ```json
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet"
    }
    ```

1. **StorageConnectionString** という名前の新しい設定を追加し、それを **「TEST VALUE」** の文字列値に設定して、**Values** オブジェクトの値を更新します。

    ```json
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet",
        "StorageConnectionString": "[TEST VALUE]"
    }
    ```

1. **local.settings.json** ファイルには次のものが含まれているはずです。

    ```json
    {
        "IsEncrypted": false,
        "Values": {
            "AzureWebJobsStorage": "UseDevelopmentStorage=true",
            "FUNCTIONS_WORKER_RUNTIME": "dotnet",
            "StorageConnectionString": "[TEST VALUE]"
        }
    }
    ```

1. 「**Visual Studio Code**」 ウィンドウの 「Explorer」 ペインで、**FileParser.cs** ファイルを開きます。
1. コード エディターで、例の実装を確認します。

    ```csharp
    using System;
    using System.IO;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Extensions.Http;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using Newtonsoft.Json;

    namespace func
    {
        public static class FileParser
        {
            [FunctionName("FileParser")]
            public static async Task<IActionResult> Run(
                [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
                ILogger log)
            {
                log.LogInformation("C# HTTP trigger function processed a request.");

                string name = req.Query["name"];

                string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
                dynamic data = JsonConvert.DeserializeObject(requestBody);
                name = name ?? data?.name;

                string responseMessage = string.IsNullOrEmpty(name)
                    ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."
                    : $"Hello, {name}. This HTTP triggered function executed successfully.";

                return new OkObjectResult(responseMessage);
            }
        }
    }
    ```

1. **FileParser.cs** ファイル内のすべてのコンテンツを削除します。
1. 次のコード行を追加して、**Microsoft.AspNetCore.Mvc**、**Microsoft.Azure.WebJobs**、**Microsoft.AspNetCore.Http**、**System**、および **System.Threading.Tasks** 名前空間の **usingディレクティブ**を追加します。

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    ```

1. **FileParser** という名前の新しい**パブリック静的**クラスを作成します。

    ```csharp
    public static class FileParser
    { }
    ```

1. **FileParser.cs** ファイルをもう一度確認します。これには次のものが含まれているはずです。

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;

    public static class FileParser
    { }
    ```

1. **FileParser** クラス内で、次のコード ブロックを追加して、**Run** という名前の新しい**パブリック静的***非同期*メソッドを作成します。このメソッドは、**Task\<IActionResult\>** 型の変数を返し、*request* という名前の **HttpRequest** 型の変数も受け取ります。

    ```csharp
    public static async Task<IActionResult> Run(
        HttpRequest request)
    { }
    ```

1. 次のコードを追加して、**name** パラメーターが **FileParser** の値に設定されている **FunctionNameAttribute** タイプの **Run** メソッドに属性を追加します。

    ```csharp
    [FunctionName("FileParser")]
    public static async Task<IActionResult> Run(
        HttpRequest request)
    { }
    ```

1. 次のコードを追加して、**methods** パラメーター配列が **GET** の単一値に設定されているタイプ **HttpTriggerAttribute** の **request** パラメーターに属性を追加します。

    ```csharp
    [FunctionName("FileParser")]
    public static async Task<IActionResult> Run(
        [HttpTrigger("GET")] HttpRequest request)
    { }
    ```

1. **FileParser.cs** ファイルをもう一度確認します。これには次のものが含まれているはずです。

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;

    public static class FileParser
    {
        [FunctionName("FileParser")]
        public static async Task<IActionResult> Run(
            [HttpTrigger("GET")] HttpRequest request)
        { }
    }
    ```

1. **Run** メソッド内で、次のコード行を入力して、**Environment.GetEnvironmentVariable** メソッドを使用して **StorageConnectionString** アプリケーション設定の値を取得し、その結果を **connectionString** という名前の**文字列**変数に格納します。

    ```csharp
    string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");
    ```

1. 次のコード行を入力して、**connectionString** 変数の値を HTTP 応答として返します。

    ```csharp
    return new OkObjectResult(connectionString);
    ```

1. **FileParser.cs** ファイルをもう一度確認します。これには次のものが含まれているはずです。

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;

    public static class FileParser
    {
        [FunctionName("FileParser")]
        public static async Task<IActionResult> Run(
            [HttpTrigger("GET")] HttpRequest request)
        {
            string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");
            return new OkObjectResult(connectionString);
        }
    }
    ```

1. 「**保存**」 を選択して、変更を **FileParser.cs** ファイルに保存します。

#### タスク 4: ローカル関数を検証する

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. open コマンド プロンプト、次のコマンドを入力し、Enter キーを選択し、.NET コンソール アプリケーションを実行します。

    ```powershell
    func start --build
    ```

    > **注**: **Azure Functions Core Tools** を使用して、「関数アプリ プロジェクトをローカルで開始する」「azure-functions-core-tools-start-function」」 のドキュメントを確認できます。
1. タスクバーで、「**Windows Terminal**」 アイコンをもう一度選択して、**Windows Terminal** アプリケーションの新しいインスタンスを開きます。
1. open コマンド プロンプトが表示されたら、次のコマンドを入力し、Enter を選択して **httprepl** ツールを起動し、ベースの URI (Uniform Resource Identifier) を ``http://localhost:7071`` に設定します。

    ```powershell
    httprepl http://localhost:7071
    ```

    > **注**: httprepl ツールによってエラー メッセージが表示されます。このメッセージが発生するのは、ツールが API の「スキャン」に使用する Swagger 定義ファイルを検索しているためです。関数プロジェクトは Swagger 定義ファイルを生成しないため、API を手動でトラバースする必要があります。
1. ツールプロンプトが表示されたら、次のコマンドを入力し、Enter を選択して対応する **api** ディレクトリを参照します。

    ```powershell
    cd api
    ```

1. 次のコマンドを入力し、Enter キーを押して、対応する **fileparser** ディレクトリを参照します。

    ```powershell
    cd fileparser
    ```

1. 次のコマンドを入力し、Enter を選択して、**get** コマンドを実行します。

    ```powershell
    get
    ```

1. HTTP リクエストの結果として返される **StorageConnectionString** の **「TEST VALUE」** 値を確認します。

    ```powershell
    HTTP/1.1 200 OK
    Content-Type: text/plain; charset=utf-8
    Date: Tue, 01 Sep 2020 23:35:39 GMT
    Server: Kestrel
    Transfer-Encoding: chunked

    [TEST VALUE]

    ```

1. 次のコマンドを入力してから、Enter を選択して **httprepl** アプリケーションを終了します。

    ```powershell
    exit
    ```

1. **Windows Terminal** アプリケーションの現在実行中のすべてのインスタンスを閉じます。

#### タスク 5: Azure Functions Core Tools を使用してデプロイする

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. open コマンド プロンプトで次のコマンドを入力し、Enter キーを押して Azure コマンド ライン インターフェイス (CLI) にログインします。

    ```powershell
    az login
    ```

1. **Microsoft Edge** ブラウザー ウィンドウで、次の操作を実行します。
    1. Microsoft アカウントの電子メール アドレスを入力し、**「次へ」** を選択します。
    1. Microsoft アカウントのパスワードを入力し、**「サインイン」** を選択します。
1. 現在開いている 「**Windows Terminal**」 ウィンドウに戻ります。サインイン プロセスが完了するのを待ちます。
1. 次のコマンドを入力し、Enter を選択して関数アプリ プロジェクトを公開します。

    ```powershell
    func azure functionapp publish <function-app-name>
    ```

    > **注**: たとえば、**関数アプリ名**が **securefuncstudent** の場合、コマンドは ``func azure functionapp publish securefuncstudent`` になります。**Azure Functions Core Tools** を使用して、「ローカル関数アプリ プロジェクトを公開する」 「azure-functions-core-tools-publish-azure」のドキュメントを確認できます。
1. ラボを進める前に、デプロイが完了するのを待ちます。
1. 現在実行中の **Windows Terminal** アプリケーションを閉じます。

#### タスク 6: Key Vault 派生アプリケーション設定のテスト

1. タスク バーで、**Microsoft Edge** アイコンを選択します。
1. 開いているブラウザー ウィンドウで、「Azure portal」(<https://portal.azure.com>)に移動します。
1. Azure portal のナビゲーション ペインで、「**リソース グループ**」 リンクを選択します。
1. 「**リソース グループ**」 ブレードで、この実習ラボで前に作成した **ConfidentialStack** リソース グループを見つけて選択します。
1. 「**ConfidentialStack**」 ブレードで、このラボで前に作成した **securefunc「yourname」** 関数アプリを選択します。
1. 「**App Service**」 ブレードで、「**関数**」 セクションから 「**関数**」 オプションを選択ます。
1. 「**関数**」 ペインで、既存の **FileParser** 関数を選択します。
1. 「**関数**」 ブレードで、「**開発者**」 セクションから 「**コード + テスト**」 オプションを選択します。
1. 関数エディターで、「**テスト/実行**」 を選択します。
1. 表示されるポップアップ ボックスで、次の操作を実行します。
    - 「**HTTP メソッド**」 リストで、「**GET**」 を選択します。
1. 「**実行**」 を選択して関数をテストします。
1. テスト実行の結果を確認します。結果は、Azure Storage 接続文字列になります。

> **レビュー**: この演習では、サービス ID を使用して Key Vault に格納されているシークレットの値を読み取り、関数アプリの結果としてその値を返しました。

### 演習 4: Azure Blob Storageデータにアクセスする

#### タスク 1: サンプルストレージ BLOB のアップロード

1. Azure portal のナビゲーション ペインで、「**リソース グループ**」 リンクを選択します。
1. 「**リソース グループ**」 ブレードで、 この実習ラボで前に作成した **ConfidentialStack** リソース グループを見つけて選択します。
1. 「**ConfidentialStack**」 ブレードで、このラボで先ほど作成した **securestor「yourname」** ストレージ アカウントを選択します。
1. 「**ストレージ アカウント**」 ブレードで、「**データ ストレージ**」 セクションにある 「**コンテナー**」 を選択します。
1. 「**コンテナー**」 セクションで、「**+ コンテナー**」 を選択します。
1. 「**新規コンテナー**」 ポップアップ ウィンドウで、次の操作を実行します。
    1. 「**名前**」 テキスト ボックスに、「**drop**」と入力します。
    1. 「**パブリック アクセス レベル**」 ドロップダウン リストで、「**BLOB (BLOB のみの匿名読み取りアクセス)**」 を選択し、「**作成**」 を選択します。
1. 「**コンテナー**」 セクションに戻り、新しく作成した **drop** コンテナーを選択します。
1. 「**コンテナー**」 ブレードで、「**アップロード**」 を選択します。
1. 「**BLOB のアップロード**」 ポップアップ ウィンドウで、次の操作を実行します。
    1. 「**ファイル**」 セクションで、「**フォルダー**」 アイコンを選択します。
    1. 「**エクスプローラー**」 ウィンドウで、**Allfiles (F):\\Allfiles\\Labs\\07\\Starter** に移動し、**records.json** ファイルを選択して、「**開く**」 を選択します。
    1. 「**ファイルが既に存在する場合は上書き**」 が選択されていることを確認し、「**アップロード**」 を選択します。  
    > **注**: この演習を続行する前に、BLOB がアップロードされるのを待ちます。
1. 「**コンテナー**」 ブレードに戻り、BLOB のリストから **records.json** BLOB を選択します。
1. 「**BLOB**」 ブレードから、BLOB メタデータを見つけて、BLOB の URL をコピーします。
1. タスク バーで、「**Microsoft Edge**」 アイコンを右クリックするか、ショートカットメニューを有効化したら、「**新しいウインドウ**」 を選択します。
1. 新しいブラウザー ウインドウで、BLOB 用にコピーした URL に移動します。
1. これで、BLOB の Java Script Object Notation (JSON) の内容が表示されます。JSON の内容が表示されたブラウザー ウィンドウを閉じます。
1. Azure portal が表示されたブラウザー ウィンドウに戻り、「**Blob**」 ブレードを閉じます。
1. 「**コンテナー**」 ブレードに戻り、「**アクセス レベル の変更**」 を選択します。
1. 「**アクセス レベルの変更**」 ポップアップ ウィンドウで、次のアクションを実行します。
    1. 「**パブリック アクセス レベル**」 ドロップダウン リストで、「**プライベート (匿名アクセスなし)**」 を選択します。
    1. 「**OK**」を選択します。
1. タスク バーで、「**Microsoft Edge**」 アイコンを右クリックするか、ショートカットメニューを有効化したら、「**新しいウインドウ**」 を選択します。
1. 新しいブラウザー ウインドウで、BLOB 用にコピーした URL に移動します。
1. リソースが見つからなかったことを示すエラー メッセージが表示されるはずです。
    > **注**: エラー メッセージが表示されない場合は、ブラウザーがファイルをキャッシュしている可能性があります。Ctrl+F5 を押して、エラー メッセージが表示されるまでページを更新します。

#### タスク 2: Azure SDK for .NET プルして構成する

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. open コマンド プロンプトで、次のコマンドを入力し、Enter を選択して、NuGet から **Azure.Storage.Blobs** パッケージのバージョン **12.6.0** を追加します。

    ```powershell
    dotnet add package Azure.Storage.Blobs --version 12.6.0
    ```

    > **注**: [Azure.Storage.Blob](https://www.nuget.org/packages/Azure.Storage.Blobs/12.6.0) NuGet パッケージは、Azure Blob Storage のコードを記述するために必要な AzureSDK for.NET のサブセットを参照します。
1. 現在実行中の **Windows Terminal** アプリケーションを閉じます。
1. 「**スタート**」 スクリーンで、「**Visual Studio Code**」 タイルを選択します。
1. 「**ファイル**」 メニューで、「**フォルダーを開く**」 を選択します。
1. 開いた「**ファイル エクスプローラー**」 ウィンドウで、**Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** を参照し、「**フォルダーの選択**」 を選択します。
1. 「**Visual Studio Code**」 ウィンドウの 「Explorer」 ペインで、**FileParser.cs** ファイルを開きます。
1. **Azure.Storage.Blobs** 名前空間の **using ディレクティブ**を追加します。

    ```csharp
    using Azure.Storage.Blobs;
    ```

1. **FileParser.cs** ファイルを確認します。これには次のものが含まれているはずです。

    ```csharp
    using Azure.Storage.Blobs;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;

    public static class FileParser
    {
        [FunctionName("FileParser")]
        public static async Task<IActionResult> Run(
            [HttpTrigger("GET")] HttpRequest request)
        {
            string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");
            return new OkObjectResult(connectionString);
        }
    }
    ```

#### タスク 3: Azure SDK for .NET を使用して Azure Blob Storage コードを記述する

1. **FileParser** クラスの **Run** メソッド内で、次のコード行を削除します。

    ```csharp
    return new OkObjectResult(connectionString);
    ```

1. 引き続き **Run** メソッド内で、次のコード ブロックを追加して、*connectionString* 変数、"drop" 文字列値、および "records.json" 文字列値をコンストラクターに渡して、**BlobClient** クラスの新しいインスタンスを作成します。

    ```csharp
    BlobClient blob = new BlobClient(connectionString, "drop", "records.json");
    ```

1. 引き続き **Run** メソッド内で、次のコードブロックを追加して、**BlobClient.DownloadAsync** メソッドを使用して、参照されている blob のコンテンツを非同期にダウンロードし、結果を *response* という名前の変数に格納します。

    ```csharp
    var response = await blob.DownloadAsync();
    ```

1. 引き続き **Run** メソッド内で、次のコードブロックを追加して、**FileStreamResult** クラス コンストラクターを使用して、*content* 変数に格納されているさまざまなコンテンツの値を返します。

    ```csharp
    return new FileStreamResult(response?.Value?.Content, response?.Value?.ContentType);
    ```

1. **FileParser.cs** ファイルをもう一度確認します。これには次のものが含まれているはずです。

    ```csharp
    using Azure.Storage.Blobs;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;

    public static class FileParser
    {
        [FunctionName("FileParser")]
        public static async Task<IActionResult> Run(
            [HttpTrigger("GET")] HttpRequest request)
        {
            string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");
            BlobClient blob = new BlobClient(connectionString, "drop", "records.json");
            var response = await blob.DownloadAsync();
            return new FileStreamResult(response?.Value?.Content, response?.Value?.ContentType);
        }
    }
    ```

1. 「**保存**」 を選択して、変更を **FileParser.cs** ファイルに保存します。

#### タスク 4: Azure Functions アプリをデプロイし検証する

1. タスク バーで、**Windows Terminal** アイコンを選択します。
1. 次のコマンドを入力し、Enter キーを選択して現在のディレクトリを課題ファイルを含む **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** 空のディレクトリに変更します。

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. open コマンド プロンプトで次のコマンドを入力し、Enter キーを選択して、Azure CLI にログインします。

    ```powershell
    az login
    ```

1. **Microsoft Edge** ブラウザー ウィンドウで、次の操作を実行します。
    1. Microsoft アカウントの電子メール アドレスを入力し、**「次へ」** を選択します。
    1. Microsoft アカウントのパスワードを入力し、**「サインイン」** を選択します。
1. 現在開いている 「**Windows Terminal**」 ウィンドウに戻ります。サインイン プロセスが完了するのを待ちます。
1. 次のコマンドを入力し、Enter を選択して関数アプリ プロジェクトを再度公開します。

    ```powershell
    func azure functionapp publish <function-app-name>
    ```

    > **注**: たとえば、**関数アプリ名**が **securefuncstudent** の場合、コマンドは ``func azure functionapp publish securefuncstudent`` になります。**Azure Functions Core Tools** を使用して、「ローカル関数アプリ プロジェクトを公開する」 「azure-functions-core-tools-publish-azure」のドキュメントを確認できます。
1. ラボを進める前に、デプロイが完了するのを待ちます。
1. 現在実行中の **Windows Terminal** アプリケーションを閉じます。
1. タスク バーで、**Microsoft Edge** アイコンを選択します。
1. 開いているブラウザー ウィンドウで、[Azure portal](<https://portal.azure.com>)に移動します。
1. Azure portal のナビゲーション ペインで、「**リソース グループ**」 リンクを選択します。
1. 「**リソース グループ**」 ブレードで、この実習ラボで前に作成した **ConfidentialStack** リソース グループを見つけて選択します。
1. 「**ConfidentialStack**」 ブレードで、このラボで前に作成した **securefunc「yourname」** 関数アプリを選択します。
1. 「**App Service**」 ブレードで、「**関数**」 セクションから 「**関数**」 オプションを選択ます。
1. 「**関数**」 ペインで、既存の **FileParser** 関数を選択します。
1. 「**関数**」 ブレードで、「**開発者**」 セクションから 「**コード + テスト**」 オプションを選択します。
1. 関数エディターで、「**テスト/実行**」 を選択します。
1. 表示されるポップアップ ボックスで、次の操作を実行します。
    - 「**HTTP メソッド**」 リストで、「**GET**」 を選択します。
1. 「**実行**」 を選択して関数をテストします。
1. テスト実行の結果を確認します。出力には、Azure Storage アカウントに保存されている **$/drop/records.json** BLOBのコンテンツが含まれます。

> **レビュー**: この演習では、C\# コードを使用してストレージ アカウントにアクセスし、BLOB のコンテンツをダウンロードしました。

### 演習 5: サブスクリプションのクリーンアップ

#### タスク 1: Azure Cloud Shellを開き、リソース グループを一覧表示する

1. Azure portal のナビゲーション ウィンドウで、**Cloud Shell** アイコンを選択して新しいシェル インスタンスを開きます。

    > **注**: **Cloud Shell** アイコンは、署名 (\>) アンダースコア文字 (\_) より大きく表されます。

1. サブスクリプションを使用して Cloud Shell を初めて開く場合は、**Azure Cloud Shell へようこそウィザード**を使って、初めて使用する Cloud Shell を構成できます。ウィザードで次の操作を実行します。

    1. ダイアログ ボックスで、シェルを構成するように求められます。**「Bash」** を選択し、選択したサブスクリプションを確認してから、**「ストレージの作成」** を選択します。

    > **注**: Cloud Shell が初回のセットアップ手順を完了するのを待ってから、ラボを進めます。Cloud Shell 構成オプションが表示されない場合は、このコースのラボで既存のサブスクリプションを使用している可能性があります。ラボは、新しいサブスクリプションを使用しているという前提で記述されます。

#### タスク 2: リソース グループの削除

1. コマンド プロンプトが表示されたら、次のコマンドを入力し、Enter を選択して **ConfidentialStack** リソース グループを削除します。

    ```powershell
    az group delete --name ConfidentialStack --no-wait --yes
    ```

1. ポータルの Cloud Shell ペインを閉じます。

#### タスク 3: アクティブなアプリケーションを閉じる

1. 現在実行中の Microsoft Edge アプリケーションを閉じます。

> **レビュー**: この実習では、このラボで使用するリソース グループを削除することで、サブスクリプションをクリーンアップしました。
