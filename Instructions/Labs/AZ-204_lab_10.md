---
lab:
    az204Title: 'ラボ 10: Azure Service Bus キューを使用してメッセージを非同期で処理する'
    az020Title: 'ラボ 10: Azure Service Bus キューを使用してメッセージを非同期で処理する'
    az204Module: 'モジュール 10: メッセージ ベース ソリューションを開発する'
    az020Module: 'モジュール 10: メッセージ ベース ソリューションを開発する'
---

# ラボ 10: Azure Service Bus キューを使用してメッセージを非同期で処理する

## Microsoft Azure ユーザー インターフェイス

Microsoft クラウド ツールは頻繁に更新されるため、このトレーニング コンテンツ作成後に一部の Azure UI が変更されている可能性があります。その結果、ラボの手順やステップが、正しく整合しない可能性があります。

Microsoft では、コミュニティから変更の必要性を通知されたとき、トレーニング コースを更新しています。しかし、クラウドの更新は頻繁に行われているため、このトレーニング コースを更新する前に、UI の変更に気づく場合があります。**その場合は、変更に適宜対応して、ラボで要求されている内容を処理してください。**

## 手順

### 開始する前に

#### ラボ環境へのログイン

次の認証情報を使用して、Windows 10 仮想マシン (VM) にログインします。
    
-   ユーザー名: **Admin**

-   パスワード: **Pa55w.rd**

> **注**: 講師が仮想ラボ環境に接続するための手順を説明します。

#### インストールされているアプリケーションを確認します

Windows 10 デスクトップでタスク バーを探します。タスク バーには、以下をはじめとする、このラボで使用するアプリケーションのアイコンが含まれています。
    
-   Microsoft Edge

-   Visual Studio Code

## アーキテクチャの図

![ユーザーが Azure Service Bus キューを使用してメッセージを非同期で処理することを示すアーキテクチャの図](./media/Lab10-Diagram.png)

### 演習 1: Azure リソースを作成する

#### タスク 1: Azure portal を開く

1.  タスク バーで、**Microsoft Edge** アイコンを選択します。

1.  ブラウザー ウィンドウで、Azure portal ([portal.azure.com](https://portal.azure.com)) を閲覧し、このラボで使用するアカウントでログインします。

    > **注**: Azure portal に初めてログインする場合は、ポータルのツアーが表示されます。ツアーをスキップしてポータルの使用を開始するには、「**開始**」を選択します。

#### タスク 2: Azure Service Bus キューを作成する

1.  Azure portal で、**リソース、サービス、ドキュメントの検索**テキスト ボックスを使用して、**Service Bus** を検索してから、結果のリストで、**「Service Bus」** を選択します。

1.  **Service Bus** ブレードで、**「+ 作成」** を選択します。

1.  **名前空間の作成**ブレードの**基本**タブで、次のアクションを実行し、**「確認および作成」** を選択します。
        
    | 設定                           | アクション                                                       |
    | --------------------------------- | ------------------------------------------------------------ |
    | **サブスクリプション** ドロップダウン リスト    |既定値のままにします。 |
    | **リソース グループ** セクション | **「新規作成」** を選択し、**「AsyncProcessor」** と入力してから、**「OK」** を選択します。|
    | **名前空間**テキスト ボックス | 「**sbnamespace**_[yourname]_」と入力します。|
    | **リージョン** ドロップダウン リスト |  Azure Service Bus をデプロイできる Azure リージョンを選択します。|
    | **価格レベル** ドロップダウン リスト |  **「基本」** を選択します。|

    次のスクリーンショットは、**名前空間の作成**ブレードの**基本**タブ上の構成された設定を示しています。
    
       ![Azure Service Bus 名前空間ブレードを作成する](./media/l10_create_sb_namespace.png)
     
1.  **確認および作成**タブで、以前の手順で選択したオプションを確認します。

1.  **「作成」** を選択し、指定された構成を使用して、**Service Bus** 名前空間を作成します。

    > **注**: このラボを進める前に、作成タスクが完了するまで待ちます。

1.  **デプロイ** ブレードで、**リソースに移動**ボタンを選択して、新しく作成された **Service Bus** 名前空間のブレードに移動します。

1.  **Service Bus** 名前空間ブレードの**設定**セクションで、**「共有アクセス ポリシー」** を選択します。

1.  ポリシーのリストで、**「RootManageSharedAccessKey」** を選択します。

1.  **SAS Policy: RootManageSharedAccessKey** ペインで、**プライマリ接続文字列**エントリの横の**クリップボードにコピー** ボタンを選択して、コピーした値を記録します。これは、このラボの後半で使用します。

    > **注**: 2 つの利用可能なキーのいずれを選んでも構いません。これらは交換可能です。

1.  **Service Bus** 名前空間ブレードの**エンティティ** セクションで、**「キュー」** を選択してから、**「+ キュー」** を選択します。

1.  **キューの作成**ブレードで、利用可能な設定を確認し、**名前**テキスト ボックスに、**「messagequeue」** と入力してから、**「作成」** を選択します。

1.  **「messagequeue」** を選択して、**Service Bus** キューのプロパティを表示します。

1.  ブラウザー ウィンドウを開いたままにします。これは、このラボの後半で再度使用します。

#### 確認

この演習では、このラボの残りの部分を通して使用する Azure **Service Bus** 名前空間と **Service Bus** キューを作成しました。

### 演習 2: .NET Core プロジェクトを作成し、メッセージを Service Bus キューに発行する

#### タスク 1: .NET Core プロジェクトを作成する

1.  ラボ コンピューターで、Visual Studio Code を起動します。

1.  Visual Studio Code の**ファイル** メニューで、**「フォルダーを開く」** を選択します。

1.  **フォルダーを開く**ウィンドウで、**Allfiles (F):\\Allfiles\\Labs\\10\\Starter\\MessagePublisher** を参照してから、**「フォルダーの選択」** を選択します。

1.  **Visual Studio Code** ウィンドウで、ショートカット メニューをアクティブ化してから、**「統合ターミナルで開く」** を選択します。

1.  ターミナル プロンプトで、次のコマンドを実行して、現在フォルダーに **MessagePublisher** という名前の新しい .NET プロジェクトを作成します。

    ```
    dotnet new console --name MessagePublisher --output .
    ```

    > **注**: **dotnet new** コマンドは、プロジェクトと同じ名前のフォルダーに新しい**コンソール** プロジェクトを作成します。

1.  次のコマンドを実行して、**Azure.Messaging.ServiceBus** パッケージのバージョン 7.2.1 を NuGet からインポートします。

    ```
    dotnet add package Azure.Messaging.ServiceBus --version 7.2.1
    ```

    > **注**: **dotnet add package** コマンドは、NuGet から **Azure.Messaging.ServiceBus** パッケージを追加します。詳細については、[Azure.Messaging.ServiceBus](https://www.nuget.org/packages/Azure.Messaging.ServiceBus/) を参照してください。

1.  ターミナル プロンプトで、次のコマンドを実行して、.NET Core コンソール アプリケーションをビルドします。

    ```
    dotnet build
    ```

1.  **「ターミナルの強制終了」** (**ごみ箱**アイコン) を選択して、ターミナル ペインと関連するプロセスを閉じます。

#### タスク 2: メッセージを Azure Service Bus キューに発行する

1.  **Visual Studio Code** ウィンドウの**エクスプローラー** ペインで、**Program.cs** ファイルを開きます。

1.  **Program.cs** ファイルのコード エディター タブで、既存のファイルのすべてのコードを削除します。

1.  コードに次の行を追加して、このファイルで参照される組み込み名前空間の使用を容易にします。

    ```csharp
    using System;
    using System.Threading.Tasks;
    ```

1.  次のコードを追加して、**Azure.Storage.Queues** パッケージに含まれる **Azure.Messaging.ServiceBus** 名前空間を NuGet からインポートします。

    ```csharp
    using Azure.Messaging.ServiceBus;
    ```
    
1.  次のコードを入力して、新しい **Program** クラスを MessagePublisher 名前空間に作成します。

    ```csharp
    namespace MessagePublisher
    {
       public class Program
       {
       }
    }
    ```

1.  **Program** クラスで次のコードを入力して、**storageConnectionString** という新しい文字列定数を作成します。

    ```csharp
    private const string storageConnectionString = "";
    ```

1.  値をこのラボの前半で記録した Service Bus 名前空間の**プライマリ接続文字列**に設定して、**storageConnectionString** 文字列定数を更新します。

1.  次のコードを入力して、この演習の前半で作成した Service Bus の名前に一致する **messagequeue** の値を使用して、**queueName** という名前の文字列定数を作成します。

    ```csharp
    private const string queueName = "messagequeue";
    ```

1.  次のコードを入力して、ターゲット キューに送信されるメッセージ数を格納する整数定数を作成します。

    ```csharp
    private const int numOfMessages = 3;
    ```

1.  次のコードを入力して、ターゲット キューに対する接続を所有する Service Bus クライアントを作成します。

    ```csharp
    static ServiceBusClient client;
    ```

1.  次のコードを入力して、ターゲット キューに対してメッセージを発行するために使用される Service Bus sender を作成します。

    ```csharp
    static ServiceBusSender sender;
    ```

1.  次のコードを入力して、非同期 **Main** メソッドを作成します。

    ```csharp
    public static async Task Main(string[] args)
    {
    }
    ```

1.  **Program.cs** ファイルを確認します。この中には次のコードが含まれているはずです。プレースホルダー `<storage-connection-string>` は、ターゲット Azure Service Bus 名前空間に対する接続文字列を表していることに注意してください。

    ```csharp
    using System;
    using System.Threading.Tasks;
    using Azure.Messaging.ServiceBus;

    namespace MessagePublisher
    {
        public class Program
        {
            private const string storageConnectionString = "<storage-connection-string>";
            private const string queueName = "messagequeue";
            private const int numOfMessages = 3;

            static ServiceBusClient client;
            static ServiceBusSender sender;

            public static async Task Main(string[] args)
            {
            }
        }
    }
    ```

1.  **Main** メソッドで、次のコードを入力して、メッセージの送信を担当する Service Bus 名前空間と **sender** への接続を提供する型 **ServiceBusClient** の *client* を初期化します。

    ```csharp
    client = new ServiceBusClient(storageConnectionString);
    sender = client.CreateSender(queueName);  
    ```

    > **注**: Service Bus クライアントは、アプリケーションの存続期間を通して、安全にキャッシュを行い、シングルトンとして使用されます。これは、定期的にメッセージを発行および読み取るときのベスト プラクティスの 1 つであると考えることができます。

1.  **Main** メソッドで、次のコードを追加して、**TryAdMessage** メソッドを使用して、複数のメッセージをバッチに組み合わせることができる **ServiceBusMessageBatch** オブジェクトを作成します。

    ```csharp        
    using ServiceBusMessageBatch messageBatch = await sender.CreateMessageBatchAsync();
    ```

1.  **Main** メソッドで、次のコード行を追加して、メッセージをバッチに追加し、メッセージ サイズがバッチによりサポートされる制限を超過した場合に例外をスローします。

    ```csharp        
    for (int i = 1; i <= numOfMessages; i++)
    {
        if (!messageBatch.TryAddMessage(new ServiceBusMessage($"Message {i}")))
        {
            throw new Exception($"The message {i} is too large to fit in the batch.");
        }
    }
    ```

1.  **Main** メソッドで、次のコード行を追加して、ターゲット キューに対して、バッチで非同期的にメッセージを発行する **sender** を使用して、try ブロックを作成します。

    ```csharp        
    try
    {
        await sender.SendMessagesAsync(messageBatch);
        Console.WriteLine($"A batch of {numOfMessages} messages has been published to the queue.");
    }

1.  **Main** メソッドで、次のコード行を追加して、**sender** および **client** オブジェクトを非同期的に破棄し、ネットワークやアンマネージド リソースを解放する finally ブロックを作成します。

    ```csharp
    finally
    {
        await sender.DisposeAsync();
        await client.DisposeAsync();
    }
    ```

1.  **Main** メソッドを確認します。次のコードで構成されています。 

    ```csharp
    public static async Task Main(string[] args)
    {
        client = new ServiceBusClient(storageConnectionString);
        sender = client.CreateSender(queueName);

        using ServiceBusMessageBatch messageBatch = await sender.CreateMessageBatchAsync();

        for (int i = 1; i <= numOfMessages; i++)
        {
            if (!messageBatch.TryAddMessage(new ServiceBusMessage($"Message {i}")))
            {
                throw new Exception($"The message {i} is too large to fit in the batch.");
            }
        }

        try
        {
            await sender.SendMessagesAsync(messageBatch);
            Console.WriteLine($"A batch of {numOfMessages} messages has been published to the queue.");
        }
        finally
        {
            await sender.DisposeAsync();
            await client.DisposeAsync();
        }
    }
    ```

1.  **Program.cs** ファイルを保存します。

1.  **Visual Studio Code** ウィンドウで、ショートカット メニューをアクティブ化してから、**「統合ターミナルで開く」** を選択します。

1.  ターミナル プロンプトで、次のコマンドを実行して、.NET Core コンソール アプリを起動します。

    ```
    dotnet run
    ```

    > **注**: エラーが発生した場合は、**Allfiles (F):\\Allfiles\\Labs\\10\\Solution\\MessagePublisher** フォルダーの **Program.cs** ファイルを確認します。

1.  ターミナル プロンプトに表示されるコンメッセージに、3 つのバッチ メッセージがキューに発行されていることが表示されていることを確認します。

1.  **「ターミナルの強制終了」** (**ごみ箱**アイコン) を選択して、ターミナル ペインと関連するプロセスを閉じます。

1.  Azure portal の Service Bus キュー **messagequeue** を表示している Microsoft Edge ブラウザーに切り替えます。

1.  **Essentials** ペインを確認します。キューに 3 つのアクティブなメッセージが含まれていることに注意してください。

    次のスクリーンショットには、Service Bus キューのメトリックとメッセージ数が表示されます。
     
       ![Azure portal の Service Bus キューのメトリックとメッセージ数](./media/l10_display_queue_with_messages_portal.png)
     
1.  **サービス** セクションで、**「Service Bus Explorer (プレビュー)」** を選択します。

1.  **Service Bus Explorer (プレビュー)** ブレードで、**ピーク** タブ ヘッダーを選択し、**ピーク** タブで、**ピーク** ボタンを選択します。

1.  キューに 3 つのメッセージが含まれることを確認します。

1.  最初のメッセージを選択し、**メッセージ** ペインで、その内容を確認します。

    次のスクリーンショットには、最初のメッセージの内容が表示されます。
         
       ![Service Bus Explorer の Service Bus キューの内容](./media/l10_peek_queue_with_messages_explorer.png)

     
1.  **メッセージ** ペインを閉じます。

#### 確認

この演習では、メッセージを Azure Service Bus キューに発行する .NET プロジェクトを構成しました。

### 演習 3.NET Core プロジェクトを作成し、メッセージを Service Bus キューから読み取る

#### タスク 1: .NET プロジェクトを作成する

1.  ラボ コンピューターで、Visual Studio Code を起動します。

1.  Visual Studio Code の**ファイル** メニューで、**「フォルダーを開く」** を選択します。

1.  **フォルダーを開く**ウィンドウで、**Allfiles (F):\\Allfiles\\Labs\\10\\Starter\\MessageReader** を参照してから、**「フォルダーの選択」** を選択します。

1.  **Visual Studio Code** ウィンドウで、ショートカット メニューをアクティブ化してから、**「統合ターミナルで開く」** を選択します。

1.  ターミナル プロンプトで、次のコマンドを実行して、現在フォルダーに **MessageReader** という名前の新しい .NET プロジェクトを作成します。

    ```
    dotnet new console --name MessageReader --output .
    ```

1.  次のコマンドを実行して、**Azure.Messaging.ServiceBus** パッケージのバージョン 7.2.1 を NuGet からインポートします。

    ```
    dotnet add package Azure.Messaging.ServiceBus --version 7.2.1
    ```

1.  ターミナル プロンプトで、次のコマンドを実行して、.NET Core コンソール アプリケーションをビルドします。

    ```
    dotnet build
    ```

1.  **「ターミナルの強制終了」** (**ごみ箱**アイコン) を選択して、ターミナル ペインと関連するプロセスを閉じます。

#### タスク 2: メッセージを Azure Service Bus キューから読み取る

1.  **Visual Studio Code** ウィンドウの**エクスプローラー** ペインで、**Program.cs** ファイルを開きます。

1.  **Program.cs** ファイルのコード エディター タブで、既存のファイルのすべてのコードを削除します。

1.  Program.cs ファイルの含まれるコードと同じコードを追加して、Azure Service Bus キューとの相互作用を許可し、名前空間を **MessageReader** に設定します。

    ```csharp
    using System;
    using System.Threading.Tasks;
    using Azure.Messaging.ServiceBus;
    
    namespace MessageReader
    {
       public class Program
       {
          private const string storageConnectionString = "";
          static string queueName = "messagequeue";
          static ServiceBusClient client;

       }
    }
    ```

1.  以前と同様に、値をこのラボの前半で記録した **Service Bus** 名前空間の**プライマリ接続文字列**に設定して、**storageConnectionString** 文字列定数を更新します。

1.  次のコードを入力して、キューからメッセージを処理するために使用される ServiceBusProcessor を作成します。

    ```csharp
    static ServiceBusProcessor processor;
    ```

1.  次のコードを入力して、処理されるときにキューにメッセージの本文を表示する静的非同期 **MessageHandler** タスクを作成し、処理が完了した後で、それらを削除します。

    ```csharp
    static async Task MessageHandler(ProcessMessageEventArgs args)
    {
        string body = args.Message.Body.ToString();
        Console.WriteLine($"Received: {body}");
        await args.CompleteMessageAsync(args.Message);
    }
    ```

1.  次のコードを入力して、メッセージの処理中に発生した例外を管理する静的非同期 **ErrorHandler** タスクを作成します。

    ```csharp
    static Task ErrorHandler(ProcessErrorEventArgs args)
    {
        Console.WriteLine(args.Exception.ToString());
        return Task.CompletedTask;
    }
    ```

1.  次のコードを入力して、非同期 **Main** メソッドを作成します。

    ```csharp
    public static async Task Main(string[] args)
    {
    }
    ```

1.  **Program.cs** ファイルを確認します。この中には次のコードが含まれているはずです。プレースホルダー `<storage-connection-string>` は、ターゲット Azure Service Bus 名前空間に対する接続文字列を表しています。

    ```csharp
    using System;
    using System.Threading.Tasks;
    using Azure.Messaging.ServiceBus;

    namespace MessageReader
    {
        class Program
        {
            static string storageConnectionString = "";
            static string queueName = "messagequeue";
            static ServiceBusClient client;
            static ServiceBusProcessor processor;

            static async Task MessageHandler(ProcessMessageEventArgs args)
            {
                string body = args.Message.Body.ToString();
                Console.WriteLine($"Received: {body}");
                await args.CompleteMessageAsync(args.Message);
            }

            static Task ErrorHandler(ProcessErrorEventArgs args)
            {
                Console.WriteLine(args.Exception.ToString());
                return Task.CompletedTask;
            }

            static async Task Main()
            {
            }
        }
    }
    ```

1.  **Main** メソッドで、次のコードを入力して、メッセージの処理を担当する Service Bus 名前空間と **processor** への接続を提供する型 **ServiceBusClient** の *client* を初期化します。

    ```csharp
    client = new ServiceBusClient(storageConnectionString);
    processor = client.CreateProcessor(queueName, new ServiceBusProcessorOptions());
    ```

    > **注**: 前述の通り、Service Bus クライアントは、アプリケーションの存続期間を通して、安全にキャッシュを行い、シングルトンとして使用されます。これは、定期的にメッセージを発行および読み取るときのベスト プラクティスの 1 つであると考えることができます。

1.  **Main** メソッドで、次のコード行を追加して、最初にメッセージとエラー処理ハンドラーを実装し、メッセージ処理を開始し、ユーザー入力に続いて、処理を中止する try ブロックを作成します。

    ```csharp        
    try
    {
        processor.ProcessMessageAsync += MessageHandler;
        processor.ProcessErrorAsync += ErrorHandler;

        await processor.StartProcessingAsync();
        Console.WriteLine("Wait for a minute and then press any key to end the processing");
        Console.ReadKey();

        Console.WriteLine("\nStopping the receiver...");
        await processor.StopProcessingAsync();
        Console.WriteLine("Stopped receiving messages");
    }

1.  **Main** メソッドで、次のコード行を追加して、**processor** および **client** オブジェクトを非同期的に破棄し、ネットワークやアンマネージド リソースを解放する finally ブロックを作成します。

    ```csharp
    finally
    {
        await processor.DisposeAsync();
        await client.DisposeAsync();
    }
    ```

1.  **Main** メソッドを確認します。次のコードで構成されています。

    ```csharp
    static async Task Main()
    {
        client = new ServiceBusClient(storageConnectionString);
        processor = client.CreateProcessor(queueName, new ServiceBusProcessorOptions());

        try
        {
            processor.ProcessMessageAsync += MessageHandler;
            processor.ProcessErrorAsync += ErrorHandler;

            await processor.StartProcessingAsync();
            Console.WriteLine("Wait for a minute and then press any key to end the processing");
            Console.ReadKey();

            Console.WriteLine("\nStopping the receiver...");
            await processor.StopProcessingAsync();
            Console.WriteLine("Stopped receiving messages");
        }
        finally
        {
            await processor.DisposeAsync();
            await client.DisposeAsync();
        }
    }
    ```

1.  **Program.cs** ファイルを保存します。

1.  **Visual Studio Code** ウィンドウで、ショートカット メニューをアクティブ化してから、**「統合ターミナルで開く」** を選択します。

1.  ターミナル プロンプトで、次のコマンドを実行して、.NET Core コンソール アプリを起動します。

    ```
    dotnet run
    ```

    > **注**: エラーが発生した場合は、**Allfiles (F):\\Allfiles\\Labs\\10\\Solution\\MessageReader** フォルダーの **Program.cs** ファイルを確認します。

1.  ターミナル プロンプトに表示されるコンメッセージに、キューの 3 つの各メッセージが受信されていることが表示されていることを確認します。

1.  ターミナル プロンプトで、任意のキーを押して、レシーバーを停止して、アプリの実行を終了します。

1.  **「ターミナルの強制終了」** (**ごみ箱**アイコン) を選択して、ターミナル ペインと関連するプロセスを閉じます。

1.  Azure portal の Service Bus キュー **messagequeue** を表示している Microsoft Edge ブラウザーに戻ります。

1.  **Service Bus Explorer (プレースホルダー)** ブレードで、**「更新」** を選択します。キュー内のアクティブなメッセージ数が **0** に変化することに注意してください。

#### 確認

この演習では、.NET ライブラリを使用して、Azure Service Bus キューからメッセージを読み取り、削除しました。

### 演習 4: サブスクリプションのクリーンアップ

#### タスク 1: Azure Cloud Shell を開く

1.  Azure portal で、**Cloud Shell** アイコン ![Cloud Shell icon](./media/az204_lab_CloudShell.png) を選択して、新しい Bash セッションを開始します。Cloud Shell が既定の PowerShell セッションである場合は、**「PowerShell」** を選択し、ドロップダウン メニューで、**「Bash」** を選択します。

    > **注**: 初めての **Cloud Shell** の起動であり、プロンプトが表示された場合は、**「Bash」** または **「PowerShell」** を選択して、**「PowerShell」** を選択します。**「ストレージがマウントされていません」** というメッセージが表示されたら、このラボで使用しているサブスクリプションを選択して、**「ストレージの作成」** を選択します。

#### タスク 2: リソース グループの削除

1.  **Cloud Shell** ペインで、次のコマンドを実行して、**AsyncProcessor** リソース グループを削除します。

    ```
    az group delete --name AsyncProcessor --no-wait --yes
    ```
    
     >**注**: コマンドは非同期に実行されるので (*--no-wait* パラメーターで決定される)、同じ Bash セッション内ですぐに別の Azure CLI コマンドを実行できますが、リソース グループが実際に削除されるまでに数分かかります。
  
1.  ポータルで、**Cloud Shell** ペインを閉じます。

#### タスク 3: アクティブなアプリケーションを閉じる

1.  現在実行中の Microsoft Edge アプリケーションを閉じます。

1.  現在実行中の Visual Studio Code アプリケーションを閉じます。

#### 確認

この実習では、このラボで使用するリソース グループを削除することで、サブスクリプションをクリーンアップしました。
